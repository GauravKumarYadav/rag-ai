"""
Agent State Management.

Provides structured state that flows through the agent reasoning pipeline,
preserving context, tracking iterations, and maintaining tenant isolation.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, TYPE_CHECKING

from pydantic import BaseModel, Field

from app.models.schemas import RetrievalHit

if TYPE_CHECKING:
    from app.services.query_processor import Intent
    from app.memory.conversation_state import ConversationState


class ActionType(str, Enum):
    """Types of actions an agent can take."""
    RETRIEVE = "retrieve"
    RETRIEVE_MORE = "retrieve_more"
    EXPAND_KG = "expand_kg"
    USE_TOOL = "use_tool"
    SYNTHESIZE = "synthesize"
    VERIFY = "verify"
    RE_RETRIEVE = "re_retrieve"
    STOP = "stop"
    DECOMPOSE = "decompose"
    DELEGATE = "delegate"


class AgentAction(BaseModel):
    """Represents an action chosen by an agent."""
    type: ActionType
    params: Dict[str, Any] = Field(default_factory=dict)
    reasoning: str = ""
    is_terminal: bool = False
    
    @classmethod
    def stop(cls, reason: str = "Task complete") -> "AgentAction":
        """Create a terminal stop action."""
        return cls(type=ActionType.STOP, reasoning=reason, is_terminal=True)
    
    @classmethod
    def retrieve(cls, query: str, strategy: str = "hybrid") -> "AgentAction":
        """Create a retrieval action."""
        return cls(
            type=ActionType.RETRIEVE,
            params={"query": query, "strategy": strategy},
            reasoning=f"Retrieving documents for: {query}"
        )
    
    @classmethod
    def use_tool(cls, tool_name: str, params: Dict[str, Any]) -> "AgentAction":
        """Create a tool use action."""
        return cls(
            type=ActionType.USE_TOOL,
            params={"tool": tool_name, **params},
            reasoning=f"Using tool: {tool_name}"
        )


class SubQuery(BaseModel):
    """A decomposed sub-query with metadata."""
    query: str
    purpose: str = ""  # Why this sub-query is needed
    depends_on: List[int] = Field(default_factory=list)  # Indices of dependent sub-queries
    retrieval_hints: List[str] = Field(default_factory=list)  # Hints for retrieval
    is_tool_query: bool = False  # If this requires a tool instead of retrieval
    tool_name: Optional[str] = None
    
    # Results populated after execution
    executed: bool = False
    results: List[RetrievalHit] = Field(default_factory=list)
    answer: Optional[str] = None


class AgentPlan(BaseModel):
    """Execution plan generated by the orchestrator."""
    sub_queries: List[SubQuery] = Field(default_factory=list)
    agent_sequence: List[str] = Field(default_factory=list)  # Order of agents to execute
    requires_tools: bool = False
    tool_names: List[str] = Field(default_factory=list)
    estimated_complexity: str = "simple"  # simple, moderate, complex
    reasoning: str = ""


class CoverageAssessment(BaseModel):
    """Assessment of how well current context covers the query."""
    is_sufficient: bool = False
    coverage_ratio: float = 0.0
    missing_entities: List[str] = Field(default_factory=list)
    missing_aspects: List[str] = Field(default_factory=list)
    needs_kg_expansion: bool = False
    confidence: float = 0.0
    notes: str = ""


class VerificationResult(BaseModel):
    """Result of answer verification."""
    passed: bool = False
    action: str = "none"  # none, re_retrieve, add_disclaimer
    refined_queries: List[str] = Field(default_factory=list)
    reason: str = ""
    citation_coverage: float = 0.0
    grounding_score: float = 0.0
    unsupported_claims: List[str] = Field(default_factory=list)
    answer: Optional[str] = None


class AgentState(BaseModel):
    """
    Shared state across agent reasoning steps.
    
    This state flows through the entire agentic pipeline, accumulating
    context and tracking progress while preserving tenant isolation.
    """
    # Query information
    query: str
    original_query: str = ""  # Preserved original
    search_query: str = ""  # Rewritten query for retrieval
    sub_queries: List[SubQuery] = Field(default_factory=list)
    
    # Intent classification
    intent: Optional[str] = None  # Intent enum value as string
    intent_confidence: float = 0.0
    needs_retrieval: bool = True
    resolved_references: List[str] = Field(default_factory=list)
    
    # Retrieval context
    retrieved_context: List[RetrievalHit] = Field(default_factory=list)
    retrieved_per_subquery: Dict[str, List[RetrievalHit]] = Field(default_factory=dict)
    
    # Tool results
    tool_results: Dict[str, Any] = Field(default_factory=dict)
    
    # Reasoning trace (scratchpad)
    scratchpad: List[str] = Field(default_factory=list)
    
    # Execution tracking
    iteration: int = 0
    max_iterations: int = 3
    correction_attempts: int = 0
    max_corrections: int = 2
    
    # Generated content
    intermediate_answers: List[str] = Field(default_factory=list)
    final_answer: Optional[str] = None
    
    # Verification
    verification_result: Optional[VerificationResult] = None
    
    # Plan
    plan: Optional[AgentPlan] = None
    
    # Tenant isolation - CRITICAL for security
    client_id: Optional[str] = None
    allowed_clients: Optional[List[str]] = None
    
    # Conversation context
    conversation_id: Optional[str] = None
    conversation_state: Optional[Any] = None  # ConversationState object
    
    # Metadata
    started_at: Optional[float] = None
    model_used: Optional[str] = None
    total_tokens_used: int = 0
    
    class Config:
        arbitrary_types_allowed = True
    
    def add_thought(self, thought: str) -> None:
        """Add a thought to the scratchpad."""
        self.scratchpad.append(f"Thought: {thought}")
    
    def add_action(self, action: str) -> None:
        """Add an action to the scratchpad."""
        self.scratchpad.append(f"Action: {action}")
    
    def add_observation(self, observation: str) -> None:
        """Add an observation to the scratchpad."""
        self.scratchpad.append(f"Observation: {observation}")
    
    def get_reasoning_trace(self) -> str:
        """Get the full reasoning trace as a string."""
        return "\n".join(self.scratchpad)
    
    def merge_retrieved(self, hits: List[RetrievalHit], subquery: Optional[str] = None) -> None:
        """
        Merge new retrieval hits into context, avoiding duplicates.
        
        Args:
            hits: New retrieval hits to merge
            subquery: Optional subquery key for tracking
        """
        existing_ids = {h.id for h in self.retrieved_context}
        
        for hit in hits:
            if hit.id not in existing_ids:
                self.retrieved_context.append(hit)
                existing_ids.add(hit.id)
        
        if subquery:
            self.retrieved_per_subquery[subquery] = hits
    
    def can_continue(self) -> bool:
        """Check if the agent can continue processing."""
        return (
            self.iteration < self.max_iterations and
            self.correction_attempts < self.max_corrections
        )
    
    def increment_iteration(self) -> None:
        """Increment the iteration counter."""
        self.iteration += 1
    
    def increment_correction(self) -> None:
        """Increment the correction counter."""
        self.correction_attempts += 1
    
    def get_context_summary(self) -> str:
        """Get a summary of current context for prompts."""
        summary_parts = []
        
        if self.retrieved_context:
            summary_parts.append(f"Retrieved {len(self.retrieved_context)} documents")
        
        if self.tool_results:
            summary_parts.append(f"Tool results: {list(self.tool_results.keys())}")
        
        if self.sub_queries:
            executed = sum(1 for sq in self.sub_queries if sq.executed)
            summary_parts.append(f"Sub-queries: {executed}/{len(self.sub_queries)} executed")
        
        return "; ".join(summary_parts) if summary_parts else "No context yet"
